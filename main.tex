% ---------------- RELAZIONE PROGETTO DI PROGRAMMAZIONE AD OGGETTI (OOP) --------
\documentclass[a4paper,12pt]{report}

% ----------------------------- PREAMBLE --------------------------------------- 

\usepackage{lmodern}
\usepackage{alltt, fancyvrb, url}
\usepackage{float}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{amsmath,amssymb,amsthm}

% Questo commentalo se vuoi scrivere in inglese.
\usepackage[italian]{babel}

\usepackage[italian]{cleveref}

\usepackage{comment}
\usepackage{microtype}
\usepackage{fancyhdr}

\usepackage[scaled=.92]{helvet}
\usepackage[T1]{fontenc}

\usepackage{lscape}

% hyperref settings
\hypersetup{
	colorlinks=true,
	linkcolor=black, %blue
	filecolor=magenta,      
	urlcolor=cyan,
	pdftitle={Sharelatex Example},
	bookmarks=true,
	pdfpagemode=FullScreen,
}

% ----------------------------- PREAMBLE END -----------------------------------

\makeindex

\title{\textbf{INGEGNERIA DEL SOFTWARE}}
\author{Alessandro Pioggia}

\begin{document}
	
	\makeatletter
	\begin{titlepage}
		\begin{center}
			{\Huge  \@title }\\[3ex] 
			{\large  \@author}\\[3ex] 
			{\large \@date}
		\end{center}
	\end{titlepage}
	\makeatother
	\thispagestyle{empty}
	\newpage
	
	%\maketitle
	
	\tableofcontents
	
	% \input: import the commands from filename.tex to target file.
	
	% \include: does a \clearpage and does an \input.
	
	\newpage
	
	\chapter{Analisi dei requisiti}
	L'analisi dei requisiti è la fase che permette, attraverso la modellazione della realtà, di redigere la specifiche dei requisiti, documento che rappresenterà l'input per le successive fasi di progettazione. Per rendere possibile la creazione un coadiuvato è necessario, da parte dell'analista, intervistare il produttore, cercando di assimilare al meglio tutte le informazioni riguardanti il dominio applicativo. \\
	In questa fase è necessario fare in modo che il documento sia chiaro, non ambiguo, accessibile e privo di contraddizioni.\\
	L'analisi è incrementale e deve comunicare gli aspetti statici, dinamici e funzionali del progetto software.
	\section{Analisi orientata agli oggetti}
	In questa tipologia di analisi vengono curati principalmente gli aspetti statici, ovvero vengono definiti gli oggetti e le relazioni presenti fra essi. Definire gli oggetti significa individuare tutte le informazioni e proprietà ad essi connesse, esse tendono a rimanere invariate nel tempo, per questo viene definito un approccio \textbf{statico}.
	\section{Analisi funzionale}
	L'analisi funzionale si pone il problema di definire le specifiche prendendo come riferimento le funzioni, ovvero viene studiata solo ed esclusivamente la relazione presente fra dati in ingresso e dati in uscita. Vengono presi in considerazione i flussi informativi, che verranno poi modificati da processi.
	\section{Analisi orientata agli stati}
	L'analisi orientata agli stati analizza i vari stati evolutivi del prodotto, in funzione di ciò, vengono analizzati i comportamenti e successivamente redatta la documentazione delle specifiche dei requisiti.
	\section{Astrazione}
	I meccanismi di astrazione utilizzati sono:
	\begin{itemize}
		\item classificazione
		\item ereditarietà (is-a)
		\item aggregazione (part-of)
		\item associazione
	\end{itemize}
	\section{Linguaggi utilizzati per la specifica dei requisiti}
	\begin{itemize}
		\item informale (linguaggio naturale, molto contradditorio e poco chiaro, sconsigliato)
		\item semiformale (utilizzo di diagrammi secondo un preciso standard, che però è semplice ed intuitivo (e/r, dfd))
		\item formale (linguaggio tecnico, difficile da comprendere e inutilmente complicato, indipendentemente dal contesto)
	\end{itemize}
	Una volta definito il tipo di linguaggio da utilizzare è necessario effettuare una distinzione fra formalismi dichiarativi e operazionali. I primi definiscono il problema indicando le proprietà che esso deve avere, i secondi ne descrivono il comportamento, nella maggior parte dei casi attraverso un modello. I formalismi operazionali sono i più indicati in questo contesto, in quanto più comprensibili e modellabili.
	\newpage
	\chapter{Progettazione}
	Se la fase di analisi vuole sincerarsi sul "che cosa" sviluppare, nella parte di progettazione ci si chiede "come" svilupparlo, dunque si ha una sorta di ponte fra analisi e codifica.
	\section{Modalità}
	Nella progettazione si suddivide il problema iniziale in più sottoproblemi, il più possibile indipendenti fra loro, questo dà la possibilità di fare gestire il lavoro a più team, anche in parallelo. Una fase di progettazione ben realizzata consente un notevole risparmio di risorse, dal momento che un eventuale errore in fase di produzione o peggio, durante la manutenzione comporta un costo molto più elevato per l'azienda.
	\section{Approccio}
	L'approccio varia in base alla strategia adottata, ne conosciamo due:
	\begin{itemize}
		\item generale
		\item specifico
	\end{itemize}
	Il primo permette di mantenere una buona elasticità, può essere modellato anche nelle fasi successive. Il secondo invece è rigido, non contempla modifiche nelle fasi successive, questo semplifica il passaggio dalla progettazione alla codifica.
	\section{Il buon progettista}
	Il buon progettista è colui che ha una buona conoscenza di tutto ciò che riguarda lo sviluppo software, sa anticipare i cambiamenti ed ha un buon grado di esperienza. Inoltre, è colui che si pone come obiettivi della progettazione l'affidabilità, la modificabilità, la comprensibilità e la riusabilità del software.	
	\newpage
	\chapter{Paradigma ad oggetti}
	La programmazione OO offre un nuovo e potente modello per scrivere programmi, gli oggetti sono scatole nere che mandano e ricevono messaggi. Questo sistema velocizza l'approccio software e migliora la riusabilità, la modificabilità e il mantenimento, richiedendo però un maggiore sforzo in fase di progettazione. I concetti fondamentali sono : oggetto, astrazione, classe, incapsulamento, ereditarietà, polimorfismo, late-binding e delegazione.
	\section{Oggetto}
	Un oggetto è una entità del dominio applicativo caratterizzata da un identificatore (unico), delle proprietà (attributi) e da un comportamento (definito da un insieme di operazioni). Gli oggetti possono essere aggregati fra loro per poter poi formare oggetti complessi.
	\section{Operazione}
	Ogni operazione è caratterizzata da un nome, dai parametri che prende come argomento e dal tipo di ritorno (signature). L'insieme di tutte le signature delle operazioni di un oggetto sono dette interfaccia dell'oggetto.
	\section{Classe}
	Una classe è la realizzazione di un tipo di dati astratto (tipo di dati astratto : insieme di oggetti simili, caratterizzati da dati e da un insieme di operazioni associate agli oggetti), cioè una implementazione per i metodi ad esso associati.
	\section{Incapsulamento}
	L'incapsulamento permette di \textbf{proteggere} dati e implementazione delle operazioni di un oggetto, attraverso una interfaccia pubblica. L'unico modo per modificare lo stato dell'oggetto (o ottenere informazioni riguardanti gli attributi) è attraverso l'utilizzo dei metodi presenti nell'interfaccia. Questo meccanismo favorisce la diminuzione della quantità di errori commessi (es:modifica di uno stato manualmente), una maggiore sicurezza, l'utilizzo (per utilizzare una classe è sufficiente conoscerne l'interfaccia pubblica) ed infine la modifica dell'implementazione di un metodo di una classe (non si ripercuote sull'applicazione).	
	\section{Metodi}
	Un metodo cattura l'implementazione di una operazione, possono essere classificati in: costruttori, distruttori, accessori e trasformatori. Un metodo può essere o privato, o pubblico o protetto.
	\section{Ereditarietà}
	Il meccanismo di ereditarietà permette di basare la definizione dell'implementazione di una classe su quella di altre classi. Una classe può \textbf{ereditare} da una superclasse ed essere \textbf{estesa} da una sottoclasse. Le sottoclassi ereditano attributi e metodi della superclasse.\\
	In certi contesti è ammessa l'ereditarietà multipla, fenomeno per il quale una sottoclasse eredita \textbf{contemporaneamente} da due superclassi.
	\section{Polimorfismo}
	Per polimorfismo si intende la capacità di assumere forme molteplici, si verifica quando:
	\begin{itemize}
		\item in una classe posso definire due metodi con stessa intestazione, a patto che abbiano una diversa signature (parametri in ingresso)
		\item posso ridefinire un metodo attraverso il meccanismo di override
	\end{itemize}
	\section{Late binding}
	Il late binding, o istanziamento dinamico, permette a ciascun oggetto di rispondere a uno stesso messaggio in modo appropriato a seconda della classe da cui deriva.
	\section{Delegazione}
	Si parla di delegazione quando un oggetto A contiene un riferimento ad un oggetto B, in questo modo A può delegare delle funzioni alla classe a cui appartiene B. Questo è il meccanismo fondamentale per quanto riguarda l'implementazione dell'associazione fra classi.
	\chapter{Ingegneria del software}
	L'ingegneria del software è la disciplina che, attraverso un approccio sistematico (tecnico e preciso), si pone come obiettivo quello di gestire l'operabilità, la manutenzione e l'eventuale ritiro dal commercio del software. Questa disciplina, oltre all'aspetto tecnico, comprende un aspetto manageriale, il quale si occupa della gestione dei flussi, dei tempi e delle risorse dell'azienda.
	\section{Qualità del software}
	Un software che funzioni non è sufficiente, è necessario che sia di qualità, esse possono essere:
	\begin{itemize}
		\item interne (visibili solamente dagli sviluppatori)
		\item esterne (visibili dall'utente finale)
		\item di prodotto (guardano la qualità del prodotto)
		\item di processo (guardano la qualità del processo produttivo)
	\end{itemize}
	\subsection{Qualità esterne, di prodotto e di processo}
	Robustezza (si comporta bene anche su aspetti non menzionati nelle specifiche di progetto)
	\subsection{Qualità esterne e di prodotto}
	Correttezza (funziona?), affidabilità (un software è affidabile se posso dipendere da esso), Efficienza (tempi e prestazioni), Facilità d'uso, portabilità e interoperabilità (utilizzo di software unito ad altri, ad esempio word e excel).
	\subsection{Qualità interne, di prodotto e di processo}
	Verificabilità (il sw è certificabile, si osserva la correttezza, performance, ecc.)
	\subsection{Qualità interne e di prodotto}
	Riusabilità e facilità di manutenzione (aperto a modifiche correttive, perfettive ed adattive).
	\subsection{Qualità esterne e di processo}
	Produttività, tempestività e trasparenza.	
	\section{Software design}
	Il sw design rappresenta il processo che trasforma le specifiche utente in un insieme di specifiche utilizzabili dai programmatori, il risultato del processo di design è l'architettura software.
	\subsection{Principi di progettazione (good practices)}
	\begin{itemize}
		\item \textbf{Formalità }(suggerisce l'uso di formalismi, ad esempio uml)
		\item \textbf{Anticipazione dei cambiamenti} (un sw robusto deve essere aperto ai cambiamenti, che siano noti o meno a priori. Le modifiche possono riguardare : hw, sw, algoritmi e dominio di applicazione)
		\item \textbf{Separazione degli argomenti} (suggerisce di spezzare il problema in sottoproblemi, in funzione del: tempo, livello di qualità (approccio incrementale), vista (in fase di analisi curare aspetti statici, dinamici e funzionali), livello di astrazione e dimensione )
		\item \textbf{Modularità} (divisione del sistema in moduli, un modulo è un componente di base di un sistema software, che permette di scomporre un sistema complesso in più componenti semplici. Tutti i servizi strettamente connessi devono appartenere allo stesso modulo e inoltre devono essere indipendenti fra loro, i programmatori devono poter operare su un modulo con una conoscenza minima del contenuto degli altri. Un modulo inoltre deve definire una interfaccia, la quale mostra le informazioni relative ad esso ma nasconde l'implementazione, si tratta di information hiding, dunque è suff. indicare una linea guida su come utilizzare i servizi. Essi interagiscono fra loro, attraverso le dipendenze [uses], composizione [part-of] e in base al tempo.)
		\item \textbf{Astrazione}
		\item \textbf{Generalità} (Ogni volta che occorre risolvere un problema, si cerca di capire quale è il problema più generale che vi si nasconde dietro.)
	\end{itemize}
	\section{Misurazione}
	La misurazione si occupa di prevedere e stimare tempi di consegna e qualità di lavorazione del software. Non è una misurazione esatta, in quanto è molto difficile quantificare, si tratta di una stima, eseguibile attraverso strumenti di diverso genere.
	\subsection{Fasi in cui è opportuno eseguire la stima}
	Scopi:\\
	La stima può avvenire in diversi stadi di lavorazione, può essere utile per prevedere le caratteristiche che avrà il software in una fase successiva alla valutazione (utile per definire azioni correttive) oppure per stimare le caratteristiche nello stadio attuale, utile per capire il costo adeguato di un software. \\
	Fasi \\
	Bisogna inoltre definire in quale momento effettuare la misurazione, essa può avvenire in:
	\begin{itemize}
		\item fase di progettazione (serve a prevedere la manutenibilità e prevenire problemi)
		\item fase di collaudo/test (eseguire un confronto con le specifiche)
		\item fase dopo il rilascio in esercizio (serve a misurare l'impatto del software, in modo da assegnarli eventualmente un costo adeguato)
	\end{itemize}
	\newpage
	\subsection{Costi}
	Prima di stimare i costi occorre effettuare una classificazione, dividendo le fonti di costo (costi per le attività generatrici) dai fattori di costo (hanno incidenza sul costo). \\ \\
	\textbf{Fonti di costo}
	\begin{itemize}
		\item Costo delle risorse per lo sviluppo del sw (costo diretto)
		\begin{itemize}
			\item personale tecnico
			\item personale di supporto (bidelli, donne delle pulizie, manutentori)
			\item risorse informatiche
			\item materiali di consumo
			\item costi generali della struttura
		\end{itemize}
		\item Costo per l'indisponibilità di un'applicazione (costo indiretto)
	\end{itemize}
	\textbf{Fattori di costo}
	\begin{itemize}
		\item Lines of code (LOC)
		\item bravura del team (un team bravo, anche se lo pago molto, mi fa risparmiare sul processo produttivo)
		\item complessità del programma
		\item stabilità dei requisiti (se cambiano idea spesso è difficile costruire un sw solido e in poco tempo)
		\item caratteristiche dell'ambiente di sviluppo
	\end{itemize}
	\subsection{Dimensioni del software}
	Le dimensioni del software si possono stimare in funzione di due tipi di metriche:
	\begin{itemize}
		\item dimensionali (si basano sul numero di istruzioni del programma)
		\item funzionali (si basano sulle caratteristiche funzionali del programma)
	\end{itemize}
	\subsection{Il metodo function points}
	Il metodo FP è empirico (basato sull'esperienza) e misura la dimensione di un sw in termini delle funzionalità offerte all'utente. Può essere utilizzato a partire dalla prima fase dello sviluppo per poi ripetere la misura nel caso le specifiche siano cambiate, è inoltre indipendente dall'ambiente tecnologico in cui si sviluppa il progetto. \\ \\
	Può essere utilizzato per:
	\begin{itemize}
		\item capire che beneficio un sw porterà alla mia organizzazione
		\item controllare che non si ladri alla vendita di un sw, c'è un fattore di proporzionalità (non posso vendere un sw di hello kitty a 3 milioni di euro)
	\end{itemize}
	\subsection{Conteggio dei function points}
	In ordine:
	\begin{itemize}
		\item individuazione del tipo di conteggio
		\begin{itemize}
			\item sviluppo software o manutenzione?
		\end{itemize}
		\item individuazione dei confini
		\begin{itemize}
			\item tutto il sistema o una sola componente?
		\end{itemize}
		\item conteggio dei FP non pesati
		\begin{itemize}
			\item funzioni di tipo dati
			\begin{itemize}
				\item file interni logici (informazioni tenute all'interno dei confini dell'applicazione)
				\item file esterni di interfaccia (dati a disposizione dell'applicazione ma mantenuti dentro i confini di un'altra applicazione)
			\end{itemize}
			\item funzioni di tipo transizione
			\begin{itemize}
				\item input esterno (dati provenienti dall'esterno elaborati all'interno dei confini dell'applicazione, es: un form)
				\item output esterno (manda dati di controllo fuori dai confini dell'applicazione, richiede almeno una formula matematica, es:una stampa)
				\item interrogazioni esterne (manda dati o informazioni fuori dai confini dell'applicazione, non richiede una formula matematica)
			\end{itemize}
		\end{itemize}
		\item calcolo dei FP pesati, in funzione del fattore di aggiustamento(varia da 0.65 a 1.35, con incidenza max sul totale del 35\%)
	\end{itemize}
	fattore di influenza = $0.65 + (TDI \cdot 0.01)$ \\
	Il $TDI$ è il total degree of influence e somma i gradi per diverse caratteristiche (es : riusabilità, comunicazione dati, prestazioni, facilità di installazione, complessità elaborativa, ecc.) ed assume valori fra 0 e 5.
	\section{Il numero ciclomatico}
	Mentre il calcolo dei FP è empirico, in questo contesto simo teorici e molto specifici, in particolare si quantifica la complessità del flusso di controllo (cicli, if, switch, ecc.). Il numero ciclomatico cattura solo in parte ciò che è la complessità del flusso di controllo.
	Il numero ciclomatico viene calcolato su un grafo fortemente connesso (ogni nodo può raggiungere indirettamente qualsiasi altro nodo). In termini di conti, il suo valore è determinabile attraverso:
	\begin{itemize}
		\item $e - n + 1$ (se il grafo è già fortemente connesso)
		\item $e - n + 2$ (se ho un grafo normale, lo posso trasformare in fortemente connesso collegando il nodo iniziale al nodo terminale)
		\item $e - n + 2p$ (se il programma ha procedure al suo interno, il numero ciclomatico dell'intero grafo è dalla somma dei numeri ciclomatici dei singoli grafi indipendenti. p è il numero di grafi (procedure) indipendenti)
	\end{itemize}
	\section{Cocomo (COnstructive COst MOdel)}
	Si calcola una stima iniziale dei costi di sviluppo in base alla dimensione del software da produrre, poi la si migliora sulla base di un insieme di parametri.
	\subsection{Stima della dimensione del software}
	Questa stima la si opera contando il numero di linee di codice scritte (KDSI), il conto lo si può fare sfruttando i FP, assegnati diversamente in funzione del linguaggio.
	\subsection{Determinazione della classe del software}
	Ci sono differenti classi software, determinate in funzione del tempo e personale richiesto, ogni classe presenta un calcolo diverso per la determinazione del costo.
	\begin{itemize}
		\item Organic $M_{nom} = 3.2 \cdot KDSI$
		\item Semi-detatched $M_{nom} = 3 \cdot KDSI$
		\item Embedded $M_{nom} = 2.8 \cdot KDSI$
	\end{itemize}
	\subsection{Applicazione degli estimatori di costo}
	Gli estimatori di costo $c_i$ sono dei coefficienti che sono determinati in funzione di :
	\begin{itemize}
		\item Proprietà del prodotto (affidabilità, complessità, ecc.)
		\item Caratteristiche hardware (efficienza, memoria, ecc.)
		\item Caratteristiche del team (esperienza e capacità del team)
		\item Caratteristiche del progetto (Modernità del processo di sviluppo, ecc.)
	\end{itemize}
	La formula esatta è la seguente:\\\\
	$M = M_{nom} \cdot \prod_{i = 1}^{15}c_i$
\end{document}
